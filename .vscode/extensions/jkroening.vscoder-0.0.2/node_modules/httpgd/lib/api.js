"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetch_remove = exports.url_remove = exports.fetch_plot = exports.url_plot = exports.fetch_plots = exports.url_plots = exports.fetch_renderers = exports.url_renderers = exports.fetch_clear = exports.url_clear = exports.fetch_info = exports.url_info = exports.fetch_state = exports.url_state = exports.new_websocket = exports.url_websocket = void 0;
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const cross_fetch_1 = require("cross-fetch");
const URL_HTTP = 'http://';
const URL_WS = 'ws://';
const URL_INFO = '/info';
const URL_STATE = '/state';
const URL_CLEAR = '/clear';
const URL_REMOVE = '/remove';
const URL_PLOTS = '/plots';
const URL_PLOT = '/plot';
const URL_RENDERERS = '/renderers';
const HEADER_TOKEN = 'X-HTTPGD-TOKEN';
function make_headers(b) {
    const headers = new cross_fetch_1.Headers();
    if (b.token) {
        headers.set(HEADER_TOKEN, b.token);
    }
    return headers;
}
function fetch_json(b, url) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield (0, cross_fetch_1.fetch)(url, {
            headers: make_headers(b)
        });
        return yield res.json();
    });
}
/**
 * Get WebSocket URL.
 *
 * @param b Httpgd backend
 * @returns URL string
 */
function url_websocket(b) {
    return URL_WS + b.host; // + (b.token ? ('&token='+b.token) : '');
}
exports.url_websocket = url_websocket;
/**
 * Creates a new WebSocket connection to an httpgd instance.
 *
 * @param b Httpgd backend
 * @returns WebSocket connection object
 */
function new_websocket(b) {
    return new isomorphic_ws_1.default(url_websocket(b));
}
exports.new_websocket = new_websocket;
/**
 * Get the URL of the `/state` API.
 *
 * @param b Httpgd backend
 * @returns URL string
 */
function url_state(b) {
    return URL_HTTP + b.host + URL_STATE;
}
exports.url_state = url_state;
/**
 * Sends a GET-request to the `/state` API.
 *
 * @param b Httpgd backend
 * @returns Response promise
 */
function fetch_state(b) {
    return fetch_json(b, url_state(b));
}
exports.fetch_state = fetch_state;
/**
 * Get the URL of the `/info` API.
 *
 * @param b Httpgd backend
 * @returns URL string
 */
function url_info(b) {
    return URL_HTTP + b.host + URL_INFO;
}
exports.url_info = url_info;
/**
 * Sends a GET-request to the `/info` API.
 *
 * @param b Httpgd backend
 * @returns Response promise
 */
function fetch_info(b) {
    return fetch_json(b, url_info(b));
}
exports.fetch_info = fetch_info;
/**
 * Get the URL of the `/clear` API.
 *
 * @param b Httpgd backend
 * @returns URL string
 */
function url_clear(b) {
    return URL_HTTP + b.host + URL_CLEAR;
}
exports.url_clear = url_clear;
/**
 * Sends a GET-request to the `/clear` API.
 *
 * @param b Httpgd backend
 * @returns Response promise
 */
function fetch_clear(b) {
    return fetch_json(b, url_clear(b));
}
exports.fetch_clear = fetch_clear;
/**
 * Get the URL of the `/renderers` API.
 *
 * @param b Httpgd backend
 * @returns URL string
 */
function url_renderers(b) {
    return URL_HTTP + b.host + URL_RENDERERS;
}
exports.url_renderers = url_renderers;
/**
 * Sends a GET-request to the `/clear` API.
 *
 * @param b Httpgd backend
 * @returns Response promise
 */
function fetch_renderers(b) {
    return fetch_json(b, url_renderers(b));
}
exports.fetch_renderers = fetch_renderers;
/**
 * Get the URL of the `/plots` API.
 *
 * @param b Httpgd backend
 * @returns URL string
 */
function url_plots(b) {
    return URL_HTTP + b.host + URL_PLOTS;
}
exports.url_plots = url_plots;
/**
 * Sends a GET-request to the `/plots` API.
 *
 * @param b Httpgd backend
 * @returns Response promise
 */
function fetch_plots(b) {
    return fetch_json(b, url_plots(b));
}
exports.fetch_plots = fetch_plots;
/**
 * Get the URL of the `/plot` API.
 *
 * @param b Httpgd backend
 * @param r Plot request object
 * @param includeToken In some cases token needs to be included in query params
 *   because request headers can't be set (e.g. img.src).
 * @param cachestr Convenience parameter will be added to the url as
 *   &c={cachestr} to circumvent caching.
 * @returns URL string
 */
function url_plot(b, r, includeToken, cachestr) {
    const url = new URL(URL_HTTP + b.host + URL_PLOT);
    if (r.id)
        url.searchParams.append('id', r.id);
    if (r.renderer)
        url.searchParams.append('renderer', r.renderer);
    if (r.width)
        url.searchParams.append('width', Math.round(r.width).toString());
    if (r.height)
        url.searchParams.append('height', Math.round(r.height).toString());
    if (r.zoom)
        url.searchParams.append('zoom', r.zoom.toString());
    if (r.download)
        url.searchParams.append('download', r.download);
    if (includeToken && b.token)
        url.searchParams.append('token', b.token);
    if (cachestr)
        url.searchParams.append('c', cachestr);
    return url.href;
}
exports.url_plot = url_plot;
/**
 * Sends a GET-request to the `/plot` API.
 *
 * @param b Httpgd backend
 * @param r Plot request object
 * @returns Response promise
 */
function fetch_plot(b, r) {
    const res = (0, cross_fetch_1.fetch)(url_plot(b, r), {
        headers: make_headers(b)
    });
    return res;
}
exports.fetch_plot = fetch_plot;
/**
 * Get the URL of the `/remove` API.
 *
 * @param b Httpgd backend
 * @param r Remove request object
 * @returns URL string
 */
function url_remove(b, r) {
    const url = new URL(URL_HTTP + b.host + URL_REMOVE);
    url.searchParams.append('id', r.id);
    return url.href;
}
exports.url_remove = url_remove;
/**
 * Sends a GET-request to the `/remove` API.
 *
 * @param b Httpgd backend
 * @param r Remove request object
 * @returns Response promise
 */
function fetch_remove(b, r) {
    return fetch_json(b, url_remove(b, r));
}
exports.fetch_remove = fetch_remove;
