"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpgdConnection = void 0;
const api = __importStar(require("./api"));
const utils_1 = require("./utils");
/**
 * Handles HTTP and WebSocket connection to httpgd server.
 *
 * Will automatically fall back to HTTP polling if WebSocket is unavailable and
 * uses a slow polling mode to eventually reconnect when the server becomes
 * completely unavailable.
 */
class HttpgdConnection {
    /**
     * Setup connection.
     *
     * Note that HttpgdConnection.open() has to be called after to open the connection.
     *
     * @param backend Httpgd backend
     * @param allowWebsockets Allow WebSocket connection.
     */
    constructor(backend, allowWebsockets) {
        this.mode = 0 /* NONE */;
        this.pausePoll = false;
        this.disconnected = false;
        this.remoteStateChanged = new utils_1.StateChangeListener();
        this.connectionChanged = new utils_1.StateChangeListener();
        this.backend = backend;
        this.allowWebsockets = allowWebsockets ? allowWebsockets : false;
    }
    /**
     * Open connection and start listening for remote changes.
     */
    open() {
        if (this.mode != 0 /* NONE */)
            return;
        this.start(3 /* WEBSOCKET */);
    }
    /**
     * Close connection and stop listening for remote changes.
     */
    close() {
        if (this.mode == 0 /* NONE */)
            return;
        this.start(0 /* NONE */);
    }
    start(targetMode) {
        if (this.mode == targetMode)
            return;
        switch (targetMode) {
            case 1 /* POLL */:
                //console.log("Start POLL");
                this.clearWebsocket();
                this.clearPoll();
                this.pollHandle = setInterval(() => this.poll(), HttpgdConnection.INTERVAL_POLL);
                this.mode = targetMode;
                break;
            case 2 /* SLOWPOLL */:
                //console.log("Start SLOWPOLL");
                this.clearWebsocket();
                this.clearPoll();
                this.pollHandle = setInterval(() => this.poll(), HttpgdConnection.INTERVAL_POLL_SLOW);
                this.mode = targetMode;
                break;
            case 3 /* WEBSOCKET */:
                if (!this.allowWebsockets) {
                    this.start(1 /* POLL */);
                    break;
                }
                //console.log("Start WEBSOCKET");
                this.clearPoll();
                this.clearWebsocket();
                this.socket = api.new_websocket(this.backend);
                this.socket.onmessage = (ev) => this.onWsMessage(ev.data.toString());
                this.socket.onopen = () => this.onWsOpen();
                this.socket.onclose = () => this.onWsClose();
                this.socket.onerror = () => this.start(2 /* SLOWPOLL */);
                this.mode = targetMode;
                this.poll(); // get initial state
                break;
            case 0 /* NONE */:
                this.clearWebsocket();
                this.clearPoll();
                this.mode = targetMode;
                break;
            default:
                break;
        }
    }
    clearPoll() {
        if (this.pollHandle) {
            clearInterval(this.pollHandle);
        }
    }
    clearWebsocket() {
        if (this.socket) {
            this.socket.onclose = () => void 0;
            this.socket.close();
        }
    }
    poll() {
        if (this.pausePoll)
            return;
        api
            .fetch_state(this.backend)
            .catch((reason) => {
            throw reason;
        })
            .then((remoteState) => {
            this.setDisconnected(false);
            if (this.mode === 2 /* SLOWPOLL */)
                this.start(3 /* WEBSOCKET */); // reconnect
            if (this.pausePoll)
                return;
            this.checkState(remoteState);
        })
            .catch(() => {
            this.setDisconnected(true);
            if (this.mode !== 2 /* SLOWPOLL */)
                this.start(2 /* SLOWPOLL */);
        });
    }
    onWsMessage(message) {
        if (message.startsWith('{')) {
            const remoteState = JSON.parse(message);
            this.checkState(remoteState);
        }
        else {
            console.log('Unknown WS message: ' + message);
        }
    }
    onWsClose() {
        //console.log('Websocket closed');
        this.setDisconnected(true);
    }
    onWsOpen() {
        //console.log('Websocket opened');
        this.setDisconnected(false);
    }
    setDisconnected(disconnected) {
        if (this.disconnected != disconnected) {
            this.disconnected = disconnected;
            if (this.disconnected) {
                this.start(2 /* SLOWPOLL */);
            }
            else {
                this.start(3 /* WEBSOCKET */);
            }
            this.connectionChanged.notify(disconnected);
        }
    }
    checkState(remoteState) {
        if (!this.lastState ||
            this.lastState.active !== remoteState.active ||
            this.lastState.hsize !== remoteState.hsize ||
            this.lastState.upid !== remoteState.upid) {
            this.lastState = remoteState;
            this.remoteStateChanged.notify(remoteState);
        }
    }
    /**
     * Listen to server state (plot or device active status) changes.
     *
     * @param fun
     */
    onRemoteChanged(fun) {
        this.remoteStateChanged.subscribe(fun);
    }
    /**
     * Listen to connection changes.
     *
     * @param fun
     */
    onConnectionChanged(fun) {
        this.connectionChanged.subscribe(fun);
    }
}
exports.HttpgdConnection = HttpgdConnection;
HttpgdConnection.INTERVAL_POLL = 500;
HttpgdConnection.INTERVAL_POLL_SLOW = 15000;
