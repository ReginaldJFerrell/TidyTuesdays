"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Httpgd = void 0;
const api_1 = require("./api");
const connection_1 = require("./connection");
const utils_1 = require("./utils");
/**
 * Manages httpgd connection and API access.
 */
class Httpgd {
    /**
     * Setup httpgd backend and connection.
     *
     * Note that Httpgd.connect() needs to be called after to open the connection
     * and start listening for remote changes.
     *
     * @param host Httpgd host
     * @param token Security token
     * @param allowWebsockets Allow WebSocket connection
     */
    constructor(host, token, allowWebsockets) {
        this.plotsChanged = new utils_1.StateChangeListener();
        this.deviceActiveChanged = new utils_1.StateChangeListener();
        this.data = {};
        this.backend = { host: host, token: token };
        this.connection = new connection_1.HttpgdConnection(this.backend, allowWebsockets);
        this.connection.onRemoteChanged((newState, oldState) => this.remoteStateChanged(newState, oldState));
    }
    /**
     * Open the connection to the httpgd backend.
     *
     * This will also cause a renderer list update and return a promise that will
     * be resolved once the renderers are updated.
     *
     * @returns Promise that will be resolved once the server information is
     *   updated (server info, list of renderers).
     */
    connect() {
        this.connection.open();
        return this.updateInfo();
    }
    /**
     * Disconnect httpgd backend.
     */
    disconnect() {
        this.connection.close();
    }
    /**
     * Listen to connection changes.
     *
     * A connection change occurs when the server goes offline or the connection
     * is interrupted.
     *
     * @param fun
     */
    onConnectionChanged(fun) {
        this.connection.onConnectionChanged(fun);
    }
    remoteStateChanged(newState, oldState) {
        if (!oldState ||
            oldState.hsize !== newState.hsize ||
            oldState.upid !== newState.upid) {
            this.updatePlots();
        }
        if (!oldState || oldState.active != newState.active) {
            this.deviceActiveChanged.notify(newState.active);
        }
    }
    localStateChanged(newState) {
        var _a;
        this.remoteStateChanged(newState, (_a = this.data.plots) === null || _a === void 0 ? void 0 : _a.state);
    }
    updateInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const res_info = (0, api_1.fetch_info)(this.backend);
            const res_renderers = (0, api_1.fetch_renderers)(this.backend);
            this.data.info = yield res_info;
            this.data.renderers = yield res_renderers;
        });
    }
    /**
     * Update plot ID list data. This will trigger `Httpgd.onPlotsChanged()` listeners.
     */
    updatePlots() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield (0, api_1.fetch_plots)(this.backend);
            this.data.plots = res;
            this.plotsChanged.notify(res);
        });
    }
    /**
     * Get plot ID list.
     *
     * @returns
     */
    getPlots() {
        return this.data.plots ? this.data.plots.plots : [];
    }
    /**
     * Get renderer list.
     *
     * @returns
     */
    getInfo() {
        var _a;
        return (_a = this.data) === null || _a === void 0 ? void 0 : _a.info;
    }
    /**
     * Get renderer list.
     *
     * @returns
     */
    getRenderers() {
        return this.data.renderers ? this.data.renderers.renderers : [];
    }
    /**
     * Get the URL of a plot.
     *
     * @param r Plot request object.
     * @returns URL string
     */
    getPlotURL(r) {
        return this.data.plots
            ? (0, api_1.url_plot)(this.backend, r, true, this.data.plots.state.upid.toString())
            : undefined;
    }
    /**
     * Get rendered plot data.
     *
     * @param r Plot request object.
     * @returns Plot data
     */
    getPlot(r) {
        return this.data.plots ? (0, api_1.fetch_plot)(this.backend, r) : undefined;
    }
    /**
     * Listen to plot changes.
     *
     * Plot changes occur when a plot changes or a new plot is added remotely in
     * the R session.
     */
    onPlotsChanged(fun) {
        this.plotsChanged.subscribe(fun);
    }
    /**
     * Listen to device active changes.
     *
     * The R GraphicsDevice becomes inactive when a other graphics device is
     * created remotely in the R session.
     *
     * @param fun
     */
    onDeviceActiveChanged(fun) {
        this.deviceActiveChanged.subscribe(fun);
    }
    /**
     * Remove a specific plot.
     *
     * @param r Remove request object
     */
    removePlot(r) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = yield (0, api_1.fetch_remove)(this.backend, r);
            return this.localStateChanged(state);
        });
    }
    /**
     * Clear all plots.
     */
    clearPlots() {
        return __awaiter(this, void 0, void 0, function* () {
            const state = yield (0, api_1.fetch_clear)(this.backend);
            return this.localStateChanged(state);
        });
    }
}
exports.Httpgd = Httpgd;
